package main

import (
	"errors"
	"fmt"
	"os"
	"path/filepath"
	"sync"

	"github.com/fatih/color"
	"github.com/idelchi/godyl/internal/tools"
	"golang.org/x/sync/errgroup"
)

// Global variable for CI stamping.
var version = "unknown - unofficial & generated by unknown"

// result struct to hold the tool and any associated error.
type result struct {
	tool *tools.Tool
	err  error
	msg  string
}

func splitTags(tags []string) ([]string, []string) {
	var with, without []string
	for _, tag := range tags {
		if tag[0] == '!' {
			without = append(without, tag[1:])
		} else {
			with = append(with, tag)
		}
	}
	return with, without
}

func main() {
	cfg, err := parseFlags()
	if err != nil {
		fmt.Fprintf(os.Stderr, "Error parsing flags: %v\n", err)
		os.Exit(1)
	}

	if err := cfg.Validate(); err != nil {
		fmt.Fprintf(os.Stderr, "Error validating configuration: %v\n", err)
		os.Exit(1)
	}

	var toolsList tools.Tools

	err = toolsList.Load(cfg.Tools)
	if err != nil {
		fmt.Fprintf(os.Stderr, "Error loading tools: %v\n", err)
		os.Exit(1)
	}

	if err := cfg.Defaults.Defaults(); err != nil {
		fmt.Fprintf(os.Stderr, "Error setting defaults: %v\n", err)
		os.Exit(1)
	}

	// Create a channel to collect the results.
	resultCh := make(chan result)

	t, wt := splitTags(cfg.Tags)

	color.Blue("*** ***")
	color.Blue("godyl running with:")
	color.Blue("*** ***")
	color.Magenta("platform:")
	color.Magenta(PrintJSON(cfg.Defaults.Platform))
	color.Blue("*** ***")

	// Set up the errgroup and concurrency limit
	g := errgroup.Group{}
	if cfg.Parallel > 0 {
		g.SetLimit(cfg.Parallel)

		color.Blue("running with %d parallel downloads", cfg.Parallel)
	}

	// Create a WaitGroup to wait for the reading of results to finish
	var wg sync.WaitGroup
	wg.Add(1) // One goroutine will be reading from the resultCh

	// Start a separate goroutine to read from the result channel.
	go func() {
		defer wg.Done() // Signal that reading is done when this goroutine exits

		// Read results from the channel as they come in.
		for res := range resultCh {
			tool := res.tool
			err := res.err
			msg := res.msg
			color.White(tool.Name)
			// Process tool results
			if err != nil {
				if errors.Is(err, tools.ErrAlreadyExists) {
					color.Yellow("  already installed")
				} else if errors.Is(err, tools.ErrDoesNotHaveTags) {
					color.Yellow("  skipped due to not having required tags")
				} else if errors.Is(err, tools.ErrSkipped) {
					color.Yellow("  skipped due to skip marker")
				} else {
					color.Red("  %v", err)
					color.Red("  %s", msg)
				}
			} else {
				if tool.Version != "" {
					color.Magenta("  version: %s", tool.Version)
				}
				color.Yellow("  picked %q", filepath.Base(tool.Path))
				color.Green("  installed successfully at %q\n", filepath.Join(tool.Output, tool.Exe))
				if tool.Aliases != nil {
					color.Magenta("  symlinks:")
					for _, alias := range tool.Aliases {
						color.Blue("    - %q\n", filepath.Join(tool.Output, alias))
					}
				}
			}
		}
	}()

	// Start goroutines for each tool.
	for _, tool := range toolsList {
		tool := tool // avoid closure capturing issue
		g.Go(func() error {
			tool.ApplyDefaults(cfg.Defaults)

			if err := tool.Resolve(t, wt); err != nil {
				resultCh <- result{tool: &tool, err: err}

				return nil
			}

			if msg, err := tool.Download(); err != nil {
				resultCh <- result{tool: &tool, err: err, msg: msg}
				return nil
			}

			// If everything succeeds, send the tool and nil error.
			resultCh <- result{tool: &tool, err: nil}

			return nil
		})
	}

	// Wait for all the goroutines to finish.
	if err := g.Wait(); err != nil {
		fmt.Fprintf(os.Stderr, "Error processing tools: %v\n", err)
	}

	// Close the result channel since no more results will be sent.
	close(resultCh)

	// Wait for the reader to finish processing all the results.
	wg.Wait()
}
